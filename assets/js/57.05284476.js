(window.webpackJsonp=window.webpackJsonp||[]).push([[57],{462:function(s,t,a){"use strict";a.r(t);var n=a(19),e=Object(n.a)({},(function(){var s=this,t=s.$createElement,a=s._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[a("p",[a("a",{attrs:{href:"https://emotion.sh/docs/introduction",target:"_blank",rel:"noopener noreferrer"}},[s._v("emotion"),a("OutboundLink")],1),s._v(" 排名第二的维护者 Sam 所在公司弃用了 css-in-js 方案，引起了不小的讨论："),a("a",{attrs:{href:"https://dev.to/srmagura/why-were-breaking-up-wiht-css-in-js-4g9b",target:"_blank",rel:"noopener noreferrer"}},[s._v("Why We're Breaking Up with CSS-in-JS"),a("OutboundLink")],1)]),s._v(" "),a("h2",{attrs:{id:"概述-精读"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#概述-精读"}},[s._v("#")]),s._v(" 概述 & 精读")]),s._v(" "),a("p",[s._v("原文很有有条理，先从 css-in-js 优点说起，再转而谈到缺点，说明了 css-in-js 这个新事物拥有明显的优点与缺点；然后从性能问题作为切入点，说明自己所在的公司为什么不得不抛弃 css-in-js；最后告诉读者目前自己的解决方案是 css-modules。")]),s._v(" "),a("p",[s._v("之后还有一点儿延展性思考，即目前还诞生了一批编译时 css-in-js 方案，但面对性能问题时依然徒劳。")]),s._v(" "),a("p",[s._v("让我们花点儿时间了解下作者的具体思路吧。")]),s._v(" "),a("h3",{attrs:{id:"css-in-js-的优缺点"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#css-in-js-的优缺点"}},[s._v("#")]),s._v(" css-in-js 的优缺点")]),s._v(" "),a("p",[s._v("css-in-js 作为一个理念较新的开发思路，拥有如下几个明显的优缺点。")]),s._v(" "),a("p",[s._v("优点：")]),s._v(" "),a("ol",[a("li",[s._v("无全局样式冲突。就像 js 文件天然支持模块化的好处一样，原生 css 因为没有模块化能力，天然容易导致全局样式污染，如果不是特意用 BEM 方式命名，想要避免冲突就只能借助 css-in-js 了。（css-modules 也一样能做到）")]),s._v(" "),a("li",[s._v("与 js 代码合在一起。天然融合进 js 代码方便模块化管理，使 css 可以与某个局部模块绑定。（css-modules 也一样能做到，只是必须单独拆一个样式文件）")]),s._v(" "),a("li",[s._v("能将 js 变量应用到样式上。虽然 css 变量也能解决这个问题，但不如 css-in-js 那么直观，inline-style 也能解决这个问题，但会产生大量重复的局部样式，且这个优势 css-modules 做不到。")])]),s._v(" "),a("p",[s._v("缺点：")]),s._v(" "),a("ol",[a("li",[s._v("css-in-js 运行时解析的实现版本增加了运行时性能压力，尤其在 React18 调度机制模式下，存在无法解决的性能问题（运行时插入样式会导致 React 渲染暂停，浏览器解析一遍样式，渲染再继续，然后浏览器又解析一遍样式）。")]),s._v(" "),a("li",[s._v("增加了包体积。相比原生或者 css-modules 方案来说，增加了运行时框架代码 8kb 左右。")]),s._v(" "),a("li",[s._v("让 ReactDevTools 结构变得复杂，因为 css-in-js 会包裹额外的 React 组件层用来实现样式插入。")])]),s._v(" "),a("p",[s._v("除了上述缺点外，css-in-js 还有三点深度使用后才能察觉的坑：")]),s._v(" "),a("ol",[a("li",[s._v("多个不同（甚至是相同）版本的 css-in-js 库同时加载时可能导致错误。笔者用 styled-components 就遇到了类似问题，甚至语法会产生不兼容的情况，虽然这些问题都可以被解决，但花费的额外时间需要计算一样，相比 css-in-js 得到的收益是否值得。")]),s._v(" "),a("li",[s._v("样式插入优先级无法自定义，这就导致产生样式覆盖时，业务对样式覆盖的优先级无法产生稳定的预期。class 优先级由 header 定义顺序决定，而非 className 的字符顺序决定，而 header 定义顺序又由资源加载与 css-in-js 插入执行时机决定，导致业务几乎不可能有稳定的样式覆盖顺序。这里产生的问题就是业务代码不断增多的 "),a("code",[s._v("!impprtant")]),s._v(" 定义。")]),s._v(" "),a("li",[s._v("不同 React 版本的 SSR，css-in-js 需要适配不同的实现，这对框架作者不太友好。")])]),s._v(" "),a("p",[s._v("除了性能问题以外，其他问题都可以忍，但偏偏在性能问题上，css-in-js 遇到了无解的场景。")]),s._v(" "),a("h3",{attrs:{id:"无解的性能问题"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#无解的性能问题"}},[s._v("#")]),s._v(" 无解的性能问题")]),s._v(" "),a("p",[s._v("第一条缺点提到的运行时解析，是 css-in-js 方案永远跨不过去的困境，即便对于编译时 css-in-js 方案来说，也免不了在渲染时做额外的逻辑执行拖慢渲染速度：")]),s._v(" "),a("div",{staticClass:"language-javascript line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-javascript"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("function")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[s._v("App")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),s._v("\n  "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("return")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("<")]),s._v("div css"),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),s._v(" color"),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v(":")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[s._v('"red"')]),s._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("/")]),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v(">")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// 就是这种代码导致了性能问题")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),s._v("\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br")])]),a("p",[s._v("原因是当 React 重渲染组件时，需要重新解析样式定义，并序列化 className，当渲染非常频繁时会导致明显的性能瓶颈，而解决方法是把样式定义抽出来，但这样就损失了第三个优点，即无法读取 js 变量了：")]),s._v(" "),a("div",{staticClass:"language-javascript line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-javascript"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("const")]),s._v(" myCss "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[s._v("css")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),s._v("\n  backgroundColor"),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v(":")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[s._v('"blue"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v("\n  width"),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v(":")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("100")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v("\n  height"),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v(":")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("100")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br")])]),a("p",[s._v("不得不说 React 的渲染机制实在是太有问题了，如果换成 SolidJS 这个问题就好办了，因为运行时的样式代码仅会运行一次，组件重渲染也不会导致这段解析代码被重复执行，此时 css-in-js 在样式变化时再做一次精确样式更新，性能问题就可以被解决了。")]),s._v(" "),a("h3",{attrs:{id:"换成-css-modules"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#换成-css-modules"}},[s._v("#")]),s._v(" 换成 css modules")]),s._v(" "),a("p",[s._v("css-modules 同时支持优点一和二，而优点三可以通过一些特定语法糖绕过：通过 "),a("code",[s._v(":import")]),s._v(" "),a("code",[s._v(":export")]),s._v(" 伪类做 css 变量的导入导出，用 webpack-loader 实现 js 中引用 css 变量，用 css variable 实现 css 引用 js 变量。")]),s._v(" "),a("p",[s._v("所以当性能问题是绕不过去的话题，而 css-modules 在性能最优的情况下，有一些曲线方案可以同时支持 css-in-js 的优点，也就能理解为什么作者要弃用 css-in-js 了。")]),s._v(" "),a("h3",{attrs:{id:"包体积真的变大了吗"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#包体积真的变大了吗"}},[s._v("#")]),s._v(" 包体积真的变大了吗")]),s._v(" "),a("p",[s._v("原文谈到的 css-in-js 增加了 8~16kb 其实是在强行堆缺点了，除非你的项目只有一行 css 定义。如果我们只考虑传输时的包体积与 HTML 中样式定义数量，而忽略运行时产生的性能负担，那么 css-in-js 在大型项目无疑是最优的。")]),s._v(" "),a("p",[s._v("原因就是 css-in-js 样式是按需插入的，没有渲染的组件就不会插入样式。甚至渲染了的组件也不一定会插入样式，因为 css-in-js 可以对包含相同样式定义的场景做 className 合并，类似于 webpack 打包时，可以把不同模块公共代码抽到一个 chunk 里。")]),s._v(" "),a("h3",{attrs:{id:"编译时-css-in-js-方案是出路吗"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#编译时-css-in-js-方案是出路吗"}},[s._v("#")]),s._v(" 编译时 css-in-js 方案是出路吗")]),s._v(" "),a("p",[s._v("理论上是出路，但限制了 css-in-js 的灵活性。从 vanilla-extract 等编译时 css-in-js 框架来看，确实解决了运行时 css-in-js 性能问题，但带来了更多语法限制，比如必须预先定义样式再使用：")]),s._v(" "),a("div",{staticClass:"language-javascript line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-javascript"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("import")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),s._v(" style "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("from")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[s._v('"@vanilla-extract/css"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("const")]),s._v(" myStyle "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[s._v("style")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),s._v("\n  display"),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v(":")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[s._v('"flex"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v("\n  paddingTop"),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v(":")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[s._v('"3px"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("const")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token function-variable function"}},[s._v("App")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=>")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("<")]),s._v("div className"),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),s._v("myStyle"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("/")]),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v(">")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br")])]),a("p",[s._v("编译时 css-in-js 想要做到通用性，只能提供一个 className，这样就不受任何框架和环境的限制了，但这样也限制了声明语法的灵活性，显然不可以用内联方式定义样式。")]),s._v(" "),a("p",[s._v("而且这种编译时的方案本质上和 css-modules 是一样的，背后都是定义了一些静态样式名，只是说这些样式问题以 "),a("code",[s._v(".sass")]),s._v(" 定义还是 "),a("code",[s._v(".ts")]),s._v(" 定义，如果用 "),a("code",[s._v(".ts")]),s._v(" 定义，配合编译工具可以使代码原生 import 的更加舒服。")]),s._v(" "),a("p",[s._v("所以使用了编译时 css-in-js 方案，本质上还是抛弃了运行时 css-in-js，投向了变种的 css-modules 阵营。")]),s._v(" "),a("h2",{attrs:{id:"总结"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[s._v("#")]),s._v(" 总结")]),s._v(" "),a("p",[s._v("css-in-js 本身方向是对的，即把 css 与 js 融合，但太过灵活的运行时 css-in-js 方案遇到了几乎不可解的性能问题，编译时的 css-in-js 方案可能是更好的出路。")]),s._v(" "),a("p",[s._v("css-in-js 这个名字本身就表示它拥有 in js 的灵活性，而编译时 css-in-js 方案本质因为是 css-module，所以不可避免拥有一些比较奇怪的限制，如果 js 里的代码不能像真的 js 一样灵活，可能还不如回到 "),a("code",[s._v(".scss")]),s._v(" 或者 "),a("code",[s._v(".less")]),s._v(" 的后缀更好理解一些。")]),s._v(" "),a("blockquote",[a("p",[s._v("讨论地址是："),a("a",{attrs:{href:"https://github.com/dt-fe/weekly/issues/450",target:"_blank",rel:"noopener noreferrer"}},[s._v("精读《我们为何弃用 css-in-js》· Issue #450 · dt-fe/weekly"),a("OutboundLink")],1)])]),s._v(" "),a("p",[a("strong",[s._v("如果你想参与讨论，请 "),a("a",{attrs:{href:"https://github.com/dt-fe/weekly",target:"_blank",rel:"noopener noreferrer"}},[s._v("点击这里"),a("OutboundLink")],1),s._v("，每周都有新的主题，周末或周一发布。前端精读 - 帮你筛选靠谱的内容。")])]),s._v(" "),a("blockquote",[a("p",[s._v("关注 "),a("strong",[s._v("前端精读微信公众号")])])]),s._v(" "),a("p",[a("a",{attrs:{href:"https://camo.githubusercontent.com/9bc4321c83f0bd36e554601c24b4e1e91309360fb66f4d6e27c048bad542a47c/68747470733a2f2f696d672e616c6963646e2e636f6d2f7466732f544231363557304d437a714b31526a535a464c5858636e325858612d3235382d3235382e6a7067",target:"_blank",rel:"noopener noreferrer"}},[a("img",{attrs:{src:"https://camo.githubusercontent.com/9bc4321c83f0bd36e554601c24b4e1e91309360fb66f4d6e27c048bad542a47c/68747470733a2f2f696d672e616c6963646e2e636f6d2f7466732f544231363557304d437a714b31526a535a464c5858636e325858612d3235382d3235382e6a7067",alt:""}}),a("OutboundLink")],1)]),s._v(" "),a("blockquote",[a("p",[s._v("版权声明：自由转载-非商用-非衍生-保持署名（"),a("a",{attrs:{href:"https://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh",target:"_blank",rel:"noopener noreferrer"}},[s._v("创意共享 3.0 许可证"),a("OutboundLink")],1),s._v("）")])])])}),[],!1,null,null,null);t.default=e.exports}}]);