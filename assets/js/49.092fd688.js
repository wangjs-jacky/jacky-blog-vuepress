(window.webpackJsonp=window.webpackJsonp||[]).push([[49],{454:function(_,v,e){"use strict";e.r(v);var t=e(19),r=Object(t.a)({},(function(){var _=this,v=_.$createElement,e=_._self._c||v;return e("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[e("h2",{attrs:{id:"_0-前言"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_0-前言"}},[_._v("#")]),_._v(" 0.前言")]),_._v(" "),e("p",[_._v("本篇博客主要为了阐述以下两个观点：")]),_._v(" "),e("ol",[e("li",[_._v("单线程是异步产生的原因。")]),_._v(" "),e("li",[_._v("事件循环 "),e("code",[_._v("eventloop")]),_._v(" 是异步实现的方式。")])]),_._v(" "),e("h2",{attrs:{id:"_1-单线程是异步产生的原因"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-单线程是异步产生的原因"}},[_._v("#")]),_._v(" 1.单线程是异步产生的原因")]),_._v(" "),e("ul",[e("li",[e("p",[_._v("因为不能是同步，只能是异步。")]),_._v(" "),e("p",[e("code",[_._v("JS")]),_._v(" 是一门单线程的语言，这是因为它运行在浏览器的渲染主线程中，而渲染主线程只有一个。渲染主线程中承担着诸多的工作，渲染页面、执行 "),e("code",[_._v("JS")]),_._v(" 都在其中运行。如果使用同步的方式，就既有可能导致主线程产生阻塞，从而导致消息队列中的很多其他任务无法得到执行。")])])]),_._v(" "),e("p",[_._v("这种异步模式下，浏览器永不阻塞，从而最大限度的保证了单线程的流畅运行。")]),_._v(" "),e("h2",{attrs:{id:"_2-事件循环是异步的实现方式。"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-事件循环是异步的实现方式。"}},[_._v("#")]),_._v(" 2. 事件循环是异步的实现方式。")]),_._v(" "),e("ul",[e("li",[e("p",[_._v("浏览器是如何实现异步的——"),e("code",[_._v("message queue")])]),_._v(" "),e("p",[_._v("具体的做法是："),e("strong",[_._v("当发生某些任务时，比如计时器、网络、事件监听，主线程将任务交给其他线程去处理，自身立即结束任务的执行，转而执行后续代码。当其他线程完成时，将事先传递的回调函数包装成任务，加入到消息队列的末尾排队，等待主线程调度执行。")])]),_._v(" "),e("p",[_._v("上述的其他线程如下：")]),_._v(" "),e("ol",[e("li",[_._v("计时器线程。")]),_._v(" "),e("li",[_._v("网络线程。")]),_._v(" "),e("li",[_._v("事件监听线程。")])])]),_._v(" "),e("li",[e("p",[_._v("事件循环/消息队列")]),_._v(" "),e("p",[_._v("事件循环（"),e("code",[_._v("eventLoop")]),_._v(" ）在"),e("code",[_._v("Chrome")]),_._v(" 中又被称为消息循环，是浏览器渲染主线程的工作方式。")]),_._v(" "),e("p",[_._v("在 "),e("code",[_._v("Chrome")]),_._v(" 的源码中，它开启一个不会结束的 "),e("code",[_._v("for")]),_._v(" 循环，每次循环从消息队列"),e("code",[_._v("message queue")]),_._v(" 中取出第一个任务执行，而其他的线程只需要在核实的时候将任务加入到队列末尾即可。")]),_._v(" "),e("p",[_._v("过去把消息队列简单分为 "),e("strong",[_._v("宏任务")]),_._v(" 和 "),e("strong",[_._v("微任务")]),_._v("，这种说法目前已无法满足复杂的浏览器环境，取而代之的是一种更加灵活多变的处理方式。")]),_._v(" "),e("p",[_._v("根据 "),e("code",[_._v("W3C")]),_._v(" 官方的解释，每个任务有不同的类型， 同类型的任务必须在同一个队列，不同的任务可以属于不同的队列。不同任务队列有不同的优先级，"),e("strong",[_._v("在一次事件循环中，由浏览器自行决定取哪一个队列的任务")]),_._v("。但浏览器必须有一个 "),e("strong",[_._v("微队列")]),_._v(" 。微队列的任务一定具有最高的优先级，必须优先调度执行。")])])]),_._v(" "),e("h2",{attrs:{id:"_3-参考"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3-参考"}},[_._v("#")]),_._v(" 3.参考")]),_._v(" "),e("ol",[e("li",[e("a",{attrs:{href:"https://ke.qq.com/webcourse/index.html",target:"_blank",rel:"noopener noreferrer"}},[_._v("渡一前端"),e("OutboundLink")],1)])])])}),[],!1,null,null,null);v.default=r.exports}}]);