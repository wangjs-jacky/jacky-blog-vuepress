---
title: 0.深入Promise原理
date: 2023-04-27 23:07:03
permalink: /pages/530f5b/
categories:
  - 重点技术
  - Promise系列
tags:
  - 
---



## 0.前言

> 本节博客代码[仓库](https://github.com/wangjs-jacky/Learn-promise)

本篇博客一开始想的标题是《从零基于 PromiseA+ 实现 Promise 源码》，但是这种文章写出来，就是一堆 `Promise` 源码的底层实现，不利于对知识的分解与重构。



## 1.实现 MVP 版本的代码

假设不存在 `Promise` 这个概念，我们就是希望实现一个状态管理函数，支持如下功能：

1. 实现一个类，该类有三个状态：`pending | fulfilled | rejected`
2. 通过接受一个 `callback` 函数可以实例化这个类，即 `new Promise(callback)`
3. 主体 `callback ` 回调函数，暴露出两个改变状态的函数。`(resolve,reject)=>{}`。
   - 当调用 `resolve()` 函数时，将类的状态修改为 `fulfilled`。
   - 当调用 `reject()` 函数时，将类的状态修改为 `rejected`。
4. 使用 `.then` 可根据状态触发不同的分支。当 `pending` 状态时，不会继续执行。当`fulfilled` 或者 `rejected` 时代码可以继续流通。



话不多说啊，开干，本案例的写法基于 `TDD` 测试驱动开发，先完成测试案例，再一步一步实现。这种开发的好处是:

1. 测试案例本身就是一份非常完善的文档。
2. 分步实现功能，不用一开始就把所有细节都考虑的完善，在一次次迭代中完善案例。



首先，先基于 `vitest` 搭建基础测试工程，具体过程可见[《vitest 测试框架环境搭建》](/pages/c21671/) 这篇博客。

将核心逻辑编写在 `src/promiseCore.ts` 文件中，测试代码 `src/promiseCore.test.ts` 文件。

基础测试代码：

```tsx
import { describe, expect, it, vi } from "vitest";
import { PromiseCore as Promise } from "./promiseCore";

/* 如果所有用例都并发执行的话，可以使用 describe.concurrent */
describe("Promise", () => {
  it("1.保证是一个类", () => {
    expect(Promise).toBeTypeOf("function");
  });
  it("2.接受一个 `callback` 函数可以实例化这个类",() => {
    expect(() => new Promise()).toThrowError("请输入函数");
    /* @ts-ignore */
    expect(() => new Promise(1)).toThrowError("请输入函数");
    /* @ts-ignore */
    expect(() => new Promise(true)).toThrowError("请输入函数");
    /* new Promise(fn) 中的 fn 立即执行 */
    const fn = vi.fn();
    new Promise(fn);
    expect(fn).toHaveBeenCalled();
  })
  it("3.callback 接受 resolve 和 reject 两个函数", () => {
     new Promise((resolve, reject) => {
      expect(resolve).toBeTypeOf("function");
      expect(reject).toBeTypeOf("function");
    });
  })
})
```

基础实现如下：

```tsx
class PromiseCore {
  state: "pending" | "fulfilled" | "rejected" = "pending";
  /* 接受案例完成实例化构建 */
  constructor(fn: Function) {
    if (typeof fn !== "function") {
      throw new Error("请输入函数");
    }
    /* 暴露出两个函数，先用空函数实现 */
    fn(this.resolve.bind(this), this.reject.bind(this));
  }
  
  /* 原形方法 */
 	resolve(){
    /* 待完善 */
  }
  reject(){
    /* 待完善 */
  }
}
```

上面的写法虽然简单，但是过前面的测试，接下来要实现 `.then` 以及修改状态这部分功能了。

```tsx
import { describe, expect, it, vi } from "vitest";
import { PromiseCore as Promise } from "./promiseCore";

/* 如果所有用例都并发执行的话，可以使用 describe.concurrent */
describe("Promise", () => {
  it("4.then 支持两个函数，也可不传", () => {
      new Promise((resolve, reject) => {}).then(null, null);
      new Promise((resolve, reject) => {}).then(
        () => {},
        () => {},
      );
    });
  
  it("4.1 promise.then(success) 中的 success 会在 resolve 被调用的时候执行", () =>
     new Promise((done) => {
    /* vitest 中的 done 写法：https://cn.vitest.dev/guide/migration.html */
    const success = vi.fn();
    const promise = new Promise((resolve, reject) => {
      expect(success).not.toHaveBeenCalled();
      setTimeout(() => {
        resolve();
      }, 10);
    });
    expect(promise.state).toMatchInlineSnapshot('"pending"');
    setTimeout(() => {
      expect(success).toHaveBeenCalled();
      expect(promise.state).toMatchInlineSnapshot('"fulfilled"');
      done();
    }, 20);
    promise.then(success);
  }));

  it("4.2 promise.then(null,fail) 中的 fail 会在 reject 被调用的时候执行", () =>
    new Promise((done) => {
      const fail = vi.fn();
      const promise = new Promise((resolve, reject) => {
        expect(fail).not.toHaveBeenCalled();
        setTimeout(() => {
          reject();
        }, 10);
      });
      expect(promise.state).toMatchInlineSnapshot('"pending"');
      setTimeout(() => {
        expect(fail).toHaveBeenCalled();
        expect(promise.state).toMatchInlineSnapshot('"rejected"');
        done();
      }, 20);
      promise.then(null, fail);
    }));
})
```

通过上面的测试案例可知，`.then` 中的函数会被 `resolve` 或者  `reject` 调用。并且

-  `.then` 是同步执行代码。
-  `.resolve` 有可能被包裹在一个异步执行环境中，至于什么时候触发不清楚。

因此这里需要做的就是：先将 `.then` 中的结果缓存起来，在`resolve` 调用的时候再从变量中取出即可。

```tsx
class PromiseCore {
  state: "pending" | "fulfilled" | "rejected" = "pending";
  succcessCallback: Function = undefined;
  failCallback: Function = undefined;
  constructor(fn: Function) {
    if (typeof fn !== "function") {
      throw new Error("请输入函数");
    }
    fn(this.resolve.bind(this), this.reject.bind(this));
  }
  
  /* 原形方法 */
 	resolve(){
    if (this.state !== "pending") return;
    this.state = "fulfilled";
    /* @todo: 这里先用 setTimeout 触发宏任务过程 */
    setTimeout(()=>{
      this.successCallback();
    })
  }
  reject(){
    if (this.state !== "pending") return;
    this.state = "rejected";
    /* @todo: 这里先用 setTimeout 触发宏任务过程 */
    setTimeout(()=>{
      this.failCallback();
    })
  }
  
  /* then 的核心就是将对应的函数缓存在 successCallback 或者 failCallback 函数中 */
  then(succeed?: CallBackType, fail?: CallBackType) {
    const handle = [] as unknown as [CallBackType, CallBackType, any];
    if (typeof succeed === "function") {
      successCallback = succeed;
    }
    if (typeof fail === "function") {
      failCallback = fail;
    }
  }
}
```

这里有可能会有一个问题：`resolve` 或 `reject` 为啥在触发的时候需要通过 `setTimeout` 包裹一层呢？

主要是考虑到下面的案例：

```tsx
new Promise((resolve,reject)=>{ resolve("成功") }).then((x)=>{console.log(x)})
```

这里 `resolve` 并不是在一个异步环境中，但是执行逻辑是:

1. 将 `(x) => console.log(x)` 保存到 `successCallback` 函数到上。
2. 这样以后才可以在 `resolve` 触发时获取到 `successCallback` 不会为 `undefined` 。

这里 `setTimeout` 的目的就是为了等一下 `then` 函数的执行，调换`resolve` 和 `then` 函数实际执行次序，现在这里先用简单的 `setTimeout` 宏任务处理，后续会替换的。

自此，一个非常简易的版本的  `Promise` 已经实现了，是不是不敢相信，`Promise` 的实现是如此的简单。虽然这种实现离一个可用的符合 `PromiseA+` 的 `Promise` 还差的很远。但是至少实现一个类状态控制器。进一步思考，是不是可以将这种编程范式扩展至其余的所需具备状态控制的领域呢？



## 2. 支持链式调用及结果传递

从本节开始完善 `Promise`，尽量往 `PromiseA+` 规范上靠。

上述已实现状态控制，但是缺少如下核心功能：

1. `promise.then` 支持多次回调存储。
2. `.then` 返回的是一个新的 `promise` （状态为 `pending`）
3. `promise(resolve => resolve("xxx")).then(x => console.log(x))` 支持将结果传递出去。

由于过程还是比较复杂的，一个测试案例一个测试案例实现：

```tsx
it("【中】2.2.6 支持链式 then 的写法，要求调用顺序遵循书写顺序", () =>
  new Promise((done) => {
  const promise = new Promise((resolve) => {
    resolve();
  });

  const callbacks = [vi.fn(), vi.fn(), vi.fn()];
  promise.then(callbacks[0]);
  promise.then(callbacks[1]);
  promise.then(callbacks[2]);
  setTimeout(() => {
    expect(callbacks[0]).toHaveBeenCalled();
    expect(callbacks[1]).toHaveBeenCalled();
    expect(callbacks[2]).toHaveBeenCalled();

    /* ChatGPT 给出的方案：如下结果分别为 [7][8][9] */
    console.log(callbacks[0].mock.invocationCallOrder);
    console.log(callbacks[1].mock.invocationCallOrder);
    console.log(callbacks[2].mock.invocationCallOrder);

    /* 0 < 1  */
    expect(callbacks[0].mock.invocationCallOrder[0]).toBeLessThan(
      callbacks[1].mock.invocationCallOrder[0],
    );

    /* 1 < 2  */
    expect(callbacks[1].mock.invocationCallOrder[0]).toBeLessThan(
      callbacks[2].mock.invocationCallOrder[0],
    );
    done();
  });
}));
```

如果希望 `.then` 支持多次回调的话，原先的变量 `successCallback` 或者 `failCallback` 就显得不够用了，需要升级为回调数组，`resolve()` 时循环触发。

```tsx
class PromiseCore {
  /* 其中 callbacks 对应如下：
  	 successCallBack <= callback[0]
  	 failCallBack <= callback[1]
  	 .then 的回调 <= callback[2]
  */
  callbacks: [CallBackType, CallBackType, myPromise][] = [];
    /* 原型方法 */
  resolve(result) {
    if (this.state !== "pending") return;
    this.state = "fulfilled";
    nextTick(() => {
      this.callbacks.forEach((handle) => {
        const success = handle[0];
        if (typeof success === "function") {
          const x = success(result);
        }
      });
    });
  }
  
  reject(reason) {
    if (this.state !== "pending") return;
    this.state = "rejected";
    nextTick(() => {
      this.callbacks.forEach((handle) => {
        const fail = handle[1];
        if (typeof fail === "function") {
          fail(reason);
        }
      });
    });
  }
}
```





第三条规则：将结果参数链式传递，我认为这条规则是 `Promise` 编码中最难实现的规则之一。





