---
title: 高阶组件基础
date: 2022-10-09 21:06:21
permalink: /pages/408842/
categories:
  - 重点技术
  - 高阶React分析
tags:
  - 
---

## 0. 前言

本篇博客主要就是讲解 `React` 高阶组件 - `HOC`。

不会讲故事，就直接开始讲解 `HOC` 的梳理工作。

本篇博客的项目演示地址：[https://wangjs-jacky.github.io/jacky-workspace-html/react18/hoc](https://wangjs-jacky.github.io/jacky-workspace-html/react18/hoc)



## 1. 什么是高阶组件？What

高阶组件`HOC` ，英文全称为 `Heigher Order Component` ，用下面一张图就可以阐述清楚

![](https://wjs-tik.oss-cn-shanghai.aliyuncs.com/image-20221009211438056.png)

由上图可知，高阶组件就是入参出餐皆为 `Component` 。



## 2. 怎么写 `HOC` ? How

高阶组件虽然简单，但是由于在 `React` 框架中存在两种类型的组件，即`Class Component` 以及 `Function Component` ，因此在实现层面上有多种写法。

### 入参`Component` 的 `Typescript` 定义怎么写？

在封装 `HOC` 时，由于不知道接受的是 `Class Component` 还是 `Function Component` ，并且离 `return` 出一个`ReactElement`，还缺一个参数 `props`，因此在定义的时候应预留出 **泛型坑位**。

假设要实现一个添加标题的 `HOC` 功能，代码如下：

```javascript
const Wrapper = (Component) => {
  return (props): JSX.Element => {
    return (
      <div>
        <header>this is header</header>
        <Component {...props} />
      </div>
    );
  };
};
```

在上述代码中，我们需要补全两个部分的 `ts` 类型定义。其一、是入参 `Compnent` 的类型。其二、是`props ` 的类型。

```javascript

/* type ComponentType<P = {}> = ComponentClass<P> | FunctionComponent<P>; */
const CreateWrapper = (title: string) => {
  /* 返回一个 HOC（即，入参组件，出参也是组件） */
  /* 难点：入参组件既有可能是一个 Class 也可能是 Function Component */
  return <P extends {}>(Component: React.ComponentType<P>) => {
    return (props: P): JSX.Element => {
      return (
        <div style={{ border: '1px solid #000' }}>
          <h2>接受的参数是：{title}</h2>
          <Component {...props} />
        </div>
      );
    };
  };
};
```



### 出参

同上，出参情况也分  `Class Component` 还是 `Function Component` 。

#### 情况一：Function Component

通过一个简单案例来了解具体写法，下面这个 `HOC` 可添加一个标题。

步骤如下：

1. 构造 `CreateWrapper`，依次接受两个参数。

   结构：`(title)=>(Component)=>Function Component`，其中 `Component=>Function Component` 为 `HOC`。

   ```javascript
   const CreateWrapper = (title: string) => {
     return <P extends {}>(Component: React.ComponentType<P>) => {
       return (props: P): JSX.Element => {
         return (
           <div style={{ border: '1px solid #000' }}>
             <h2>接受的参数是：{title}</h2>
     				/* HOC 功能：属性继承  */
             <Component {...props} />
           </div>
         );
       };
     };
   };
   ```

2. 使用 `CreateWrapper` 创造具有一个相同 `title` 的 `HOC`

   ```javascript
   const HOC = CreateWrapper('child1');
   ```

3. 使用 `HOC` 生成可供消费组件

   ```javascript
   const Wrapper = HOC(ComponentA);
   ```

4. 将 `Function Componet` 渲染到页面。

   有两种渲染方式，见下：

   ```javascript
   const Main = () => {
     /* 此组件可以传递参数 */
     return (
       <>
         <Wrapper attr="使用方案1"></Wrapper>
         <br></br>
         {HOC(ComponentA)({ attr: '使用方案2' })}
       </>
     );
   };
   export default Main;



#### 情况二：`Class Component`

当输出组件为类组件时，情况有所不同，可通过 **反向继承** 的方式完成组件的包裹`(wrap)`

步骤如下：

1. 构造 `CreateWrapper`，依次接受两个参数。

   结构：`(title)=>(Component)=>Class Component`，其中 `Component=>Class Component` 为 `HOC`。

   ```javascript
   const CreateWrapper = (title: string) => {
     return <P extends {}>(Component: React.ComponentType<P>) => {
       /* 反向继承 */
       return class XXX extends React.Component<P, {}> {
         render() {
           return (
             <div style={{ border: '1px solid #000' }}>
               <h2>当前组件是：{title}</h2>
               <Component {...this.props} />
             </div>
           );
         }
       };
     };
   };
   ```

2. 使用 `CreateWrapper` 创造具有一个相同 `title` 的 `HOC`

   ```javascript
   const HOC = CreateWrapper('child2');
   ```

3. 使用 `HOC` 生成可供消费组件

   ```javascript
   const Wrapper = HOC(ComponentA);
   ```

4. 将 `Class Componet` 渲染到页面。

   同样有两种渲染方式，注意 `Class` Componet 的渲染需要实例化

   ```javascript
   const Main = () => {
     /* 此组件可以传递参数 */
     const Element = new Wrapper({ attr: '使用方法2' }).render();
     return (
       <>
         <Wrapper attr="使用方案1"></Wrapper>
         <br></br>
         {Element}
       </>
     );
   };
   export default Main;
   ```



## 

## 3.小结

本篇博客主要内容如下：

- 使用 `React.ComponentTyp` 定义处理接受的组件既可以是类组件也可以是函数组件。

- 当 `HOC` 返回的是一个  `Function Component` 时。

  除了传统的 `<Compoent />` ，还可以通过 `HOC(Compoent)(props)` 获取 `JSX.Element` 并渲染在页面上。

- 当 `HOC` 返回的是一个 `Class Component` 时。

  需要使用**反向继承** 的方式对组件进行 `Wrap` 包裹。

  并且也提供了两种渲染方式，除了传统的 `<Compoent />` ，还可以通过构建实例对象，并调用 `render` 函数的方式获取 `JSX.Element` 并渲染在页面上。











