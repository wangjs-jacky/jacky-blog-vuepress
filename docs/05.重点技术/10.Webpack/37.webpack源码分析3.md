---
title: webpack源码分析3
date: 2022-04-05 13:23:34
permalink: /pages/c14890/
categories:
  - 重点技术
  - Webpack
tags:
  - 
---


## 0.前言

在前两篇中基本已经将 `mini-webpack` 基础原理实现，从本篇文章开始`webpack` 源码之旅。



## 1.调试`webpack`：如何搭建一个调试`DEMO`

### 方案1：`node_modules` 依赖中的

### 方案2：使用 `yarn link` 调试大法

### 方案3：使用`.launch` + `node` 脚本编写 





## 2.源码解读-梳理生命周期





## 3.带着问题看源码

### 3.1 webpack 启动方式

> 这个问题也等价于：`webpack-cli` 与 `wabpack` 的区别。

调用`webpack`的方式一般有以下两种方式：

#### 1. 终端启动

在终端中通过 `webpack-cli` 脚手架启动，以下几种写法均可：

```shell
./node_modules/.bin/webpack-cli  # 原始版
./node_modules/webpack-cli/bin/cli.js # 执行 webpack-cli 
npx webpack-cli # 简化写法
```

以上文件默认找的`src/index.js` 文件，写全一点的写法：

```shell
npx webpack-cli ./src/index.js --config ./webpack.config.js
```

> 注：在测试的时候发现，上述的 `webpack-cli` 也可以简写为 `webpack` ，但实际调用的仍是`webpcak-cli`的脚本，这点可以在`webpack-cli/bin/cli.js` 脚本中打断点验证。

#### 2. 脚本启动

在 `Node` 脚本中，可以直接`require` 的方式：

```javascript
const webpack = require('../lib/index.js')  // 直接使用源码中的webpack函数
const config = require('./webpack.config')
const compiler = webpack(config)
compiler.run((err, stats)=>{
    if(err){
        console.error(err)
    }else{
        console.log(stats)
    }
})
```

#### 3. 源码：`webpack-cli` 与 `webpack` 的关系

从名称即可看出两者的作用是不同的，`cli`全称为`command Line Interface` ，即命令行界面。`webpack-cli` 赋予终端以更灵活的方式调用`webpack` ，如下：

```shell
# 以 生产模式 打包应用
npx webpack --mode="production"
```

可以使用 `webpack.config.js` 配置 `WebPack`。发送到 `CLI` 的任何参数都将映射到配置文件中的相应参数。

##### 源码解析1：为啥 `npx webpack` 与  `npx webpack-cli` 等价

在 `webpack/bin/`中本质调用还是 `webpack-cli`，第一步就会去检测`webpack-cli` 的安装情况，如果没有安装还会自动会当前使用的包管理器（`npm`、`pnpm`、`npm`）提示你去下载：

```javascript
const cli = {
	name: "webpack-cli",
	installed: isInstalled("webpack-cli"),
	url: "https://github.com/webpack/webpack-cli" // 地址提前准备好
};
if (!cli.installed){
	console.err("你需要去装 cli 脚本了！")
  console.log("需不需要我帮你去装?(yes/no)") => 一堆安装逻辑
}else{
  require("webpack-cli")
}
```

##### 源码解析2：`webpack-cli` 本质调用的还是`webpack` 

> 由于 `webpack` 文件过于庞大，先去看`package.json` 文件中的`main`字段，主文件为：`webpack/lib/index.js` 

```javascript
const fn = lazyFunction(() => require("./webpack"));
module.exports = mergeExports(fn, { .....})
```



### 3.2 寻找 `webpack` 编译起点：`Entry`

根据第2章的内容可知，在 `compile` 函数中出现的钩子有：

`beforeCompile --> compile --> make --> finishMake--> afterCompile`。

根据经验，猜测入口分析流程应位于 `make` ->`finishMake` 之间，而两者之间并无代码，于是需要反向查找`make`钩子是在哪里注册的。

通过搜索关键词 `hooks.make.tapAsync` 找到了 `lib/EntryPlugin.js `中。

> 由于搜索出的结果很多，需要一个一个比对寻找到与入口`Entry` 有关的文件。

按照以下函数调用链条一层一层找：

`compiler.hooks.make.tapAsync("EntryPlugin")` |`this`指的是 `compilation` $\rightarrow$ `this.addEntry()` $\rightarrow$ `this._addEntryItem() ` $\rightarrow$  `this.addModuleChain()` $\rightarrow$ `this.handleModuleCreation()` $\rightarrow$ `this.factorizeModule()` $\rightarrow$ `this.factorizeModule()` $\rightarrow$  `this.addModule()`  $\rightarrow$ `this.buildModule()`

> 涉及两个文件 `lib/EntryPlugin`、`lib/Compilation`

**重点模块解读**：`addModuleChain`

```java
......
const moduleFactory = this.dependencyFactories.get(Dep);
this.handleModuleCreation(factory: moduleFactory,....){.....}
```

通过后续分析，我们逐渐意识到**工厂模式**是后续所有步骤的理论基础。

其中，`this` 是`compilation`，通过在 `EntryPlugin` 中搜索`compilation.dependencyFactories.set` 可以发现如下代码：

```javascript
compiler.hooks.compilation.tap(
  "EntryPlugin",
  (compilation, { normalModuleFactory }) => {
    compilation.dependencyFactories.set(
    EntryDependency,
    normalModuleFactory
  );
  }
);
```

由上可知，后续的 `factory` 即为 `normalModuleFactory` ，一般简称为 `nmf` 对象。



**重点模块解读**：`handleModuleCreation`：处理模块创建

```javascript
// 函数定义：
handleModuelCreation{ factory, dependencies,...},callback){
  const moduleGraph = this.moduleGraph; // 找到 depRelation
  const currentProfile = ... // Profile 与性能有关，可以忽略
  this.factorizeModule(...){    // 工厂化依赖
    	this.addModule(...){newModule, (err,module)=>{
        ...
        // 将依赖添加到 depRelation 中
        for (let i = 0; i < dependencies.length; i++) {
          const dependency = dependencies[i];
          moduleGraph.setResolvedModule(originModule, dependency, module);
        }
        this.buildModule(module,err=>{....})
      }}
  }
}
```

上述我们得到了一条非常关键的函数调用链条：

`factorizeModule()`  $\rightarrow$ `addModuel() ` $\rightarrow$ `buildModule()`

再细化下各个函数的调用栈：

`factorizeModule` ：`factorizeQueue` $\rightarrow$ `_factorizeModule` $\rightarrow$ `factory.create()`

函数内部本质就是一个工厂队列， 加入到此队列中的函数，对应只需要见处理函数为：`processor`

```javascript
// factorizeModule 函数中
this.factorizeQueue = new AsyncQueue({
  name: "factorize",
  parallelism: options.parallelism || 100,
  processor: this._factorizeModule.bind(this)
});

// _factorizeModule 函数中：
_factorizeModule(...) {
		...
		factory.create(...){...} // 由此引出一个关键函数 factory.create
		... 
}
```

前述中已说明 `factory` 即为 `nmf` 对象，于是我们找到`NormalModuleFactory.js` 文件：



**重点模块解读**：`NormalModuleFactory.create()` 创建一个新模块

涉及到的 `Hooks` 调用次序为：`hooks.beforeResolve` -> `hooks.factorize` -> `hooks.afterResolve` ->`hooks.createModule`

```javascript
// 最后一次调用：
this.hooks.createModule.callAsync(
  createData,
  resolveData,
  (err, createdModule) => {
    if (!createdModule) {
			......
      createdModule = new NormalModule(createData); // createModule
    }
    .... 
    return callback(null, createdModule); // 这里 null-> error，createModule->newModule
  }
);
```



**重点模块解读**：`addModuel` 接受 `factorizeModule`（也即，`nmf.create()`） 传递而来的 `createModule`

```javascript
this.factorizeModule(...,(err,newModule)){
  this.addModule(newModule, (err, module) => {})
}
```

函数调用链：`addModuleQueue` -> `new AsyncQueue` -> `processor: this._addModule`

核心代码：

```javascript
class Compilation {
  constructor(){
    this.modules = new Set();
    this._modules = new Map(); // _modules 私有变量标识当前 module 是否已经被添加过
    ...
  }
  ...
  this._addModule(){
      const identifier = module.identifier();  // 读取 module 唯一的id
      const alreadyAddedModule = this._modules.get(identifier); 
      if (alreadyAddedModule) {                // 如果添加过 module 则弹出
        return callback(null, alreadyAddedModule);
      }
      this._modulesCache.get(identifier, null, (err, cacheModule) => {
        this._modules.set(identifier, module); // 标识 module 已处理过
        this.modules.add(module);              // 将 module 存入 compilation.modules
      }
  }
  ...
};
```



**重点模块解读**：`buildModule`

函数调用链：`buildQueue` -> `new AsyncQueue` -> `processor: this._buildModule.bind(this)`->`hooks.buildModule`->`module.build()`-> `this.doBuild` ->`hooks.succeedModule`/`hooks.failedModule`

当前步骤是构建的重要步骤，难点在于`module.build` 这里的 `module` 是什么？`NormalModule`实例化

> 这里就不详细演示了，耐心点往上翻就会发现这里`createdModule = new NormalModule(createData);`

于是我们看下：`NormalModule.build` 做了什么？

```javascript
build(...){
    this._source = null; // 源代码存放位置
    this._ast = null;    // 初始化 ast 树
    ....
    return this.doBuild(...){
  		const handleParseError = err=>{};
  		const handleParseResult = ()=>{return handleBuildDone}; // 这种写法完全可以避免回调地狱
  		const handleBuildDone = ()=>{};
  		const noParseRule = options.module && options.module.noParse;//控制当前module是否会被解析
      // 开始解析 ast 树
  		let result;
      try {
        result = this.parser.parse(this._ast || this._source.source(), { // parse阶段：_source=>_ast
         		......
        });
      } catch (e) {
        handleParseError(e);
        return;
      }
  		handleParseResult(result);
		}
}
```

再来看下 `doBuild` 函数定义中，有什么值得关注的事件？

```javascript
doBuild(){
  // 获取 compilation 的 Hooks
  const hooks = NormalModule.getCompilationHooks(compilation);
 	hooks.beforeLoaders.call(this.loaders, this, loaderContext);
  runLoaders(
			{
				resource: this.resource, // 加载初始代码，如 案例1中的 `es6Code`
				loaders: this.loaders,   // 将各种 loaders 加载进来。
				context: loaderContext,
				readResource: (resource, callback) => {
					const scheme = getScheme(resource); // scheme 一般指协议
					if (scheme) {
						.......
					} else {
            // 正常走此回调
						fs.readFile(resource, callback); // 加载外部资源
					}
				}
			},
			(err, result) => {...}
}
```

在 `doBuild` 大致做两件事：

1. `hooks.beforeLoaders`：触发定义在 `loaders` 之前的所有事件。

2. `runLoaders`：触发 `loaders` 阶段，这步的含义在于，`webpack` 只能读取`js`文件，通过 `loader` 处理非 `js` 文件。

   此阶段还有一个任务：读文件，即 `resource` 。

最后，`handleModuleCreation` 会将上述所有的产生的队列`Queue`关闭：

```javascript
this.handleModuleCreation(
  {
    factory: moduleFactory,
    dependencies: [dependency],
    originModule: null,
    context
  },
  err => {
    if (err && this.bail) {
      callback(err);
      this.buildQueue.stop();
      this.rebuildQueue.stop();
      this.processDependenciesQueue.stop();
      this.factorizeQueue.stop();
    } else {
      callback();
    }
  }
);
```

### 3.3 `webpack` 解析阶段

解析阶段：将经上述 `loaders` 转化后的代码，解析为`AST` 语法树。

由上可知，对 `sourceCode` 进行 `parse` 的阶段是在 `doBuild    ` 函数调用 `parser.parse` 方法 ，其中`parser` ，即解析器具体的代码可以在 `lib/javascript/JavaScriptParser.js` 文件中找到：

```javascript
const { Parser: AcornParser } = require("acorn");
```

可知， `Webpack` 中并未自己实现一个`parser`，而是借助 `acorn` 的 `parser` 分析 `JS`。

在`JavaScriptParser.js` 文件中我们可以验证 `parse` 是如何进行模块收集的：

```javascript
// 遍历声明 ：Block pre walking iterates the scope for【block variable declarations】
blockPreWalkStatements(statements) {
  for (let index = 0, len = statements.length; index < len; index++) {
    const statement = statements[index];
    this.blockPreWalkStatement(statement);
  }
}

blockPreWalkStatement(statement) {
  this.statementPath.push(statement);
  if (this.hooks.blockPreStatement.call(statement)) {
    this.prevStatement = this.statementPath.pop();
    return;
  }
  switch (statement.type) {
    // 对应着 动态导入： `import("....")`
    case "ImportDeclaration":
      this.blockPreWalkImportDeclaration(statement); 
      break;
    case "ExportAllDeclaration":
      this.blockPreWalkExportAllDeclaration(statement);
      break;
    
    // 对应这默认导入： `import a from "a.js"`
    case "ExportDefaultDeclaration":
      this.blockPreWalkExportDefaultDeclaration(statement);
      break;
      
    // 对应着声明导入： `import {a} from "a.js"`
    case "ExportNamedDeclaration":
      this.blockPreWalkExportNamedDeclaration(statement);
      break;
    case "VariableDeclaration":
      this.blockPreWalkVariableDeclaration(statement);
      break;
    case "ClassDeclaration":
      this.blockPreWalkClassDeclaration(statement);
      break;
  }
  this.prevStatement = this.statementPath.pop();
}
```

根据不同的`import`情况，会触发不同的`hooks`钩子函数，这些钩子的监听函数代码保存在`lib/dependencies/HarmonyExportDependencyParserPlugin.js` 中，目的是收集各个模块的依赖，将其记录在`module.denpendencies` 数组中。

### 3.4 如何把 `modules` 合并为一个文件？

1. 生成 `chunk` 阶段

   在`compilation.seal()` 阶段，函数会创建`chunks`、并为每个 `chunk` 进行 `codeGeneration`，然后为每一个 `chunk` 创建 `assets`。

2. 生成 `assets` 阶段

   在第二章可知在 `onCompiled` 阶段，存在一个重要的函数`emitAssets()`，`emit` 意为触发，`Assets` 意为资产，此处则指的是合并生成后的文件，主要逻辑如下：

   ```javascript
   emitAssets(compilation,callback){
     let outputPath; // 指定输出路径
     const emitFiles = err =>{
      	...
       const processExistingFile = stats => {
         const content = getContent(); // 获取内容
         return this.outputFileSystem.readFile(...,()=>{ // 进入 read 阶段
           	return doWrite(content)   // 进入 write 阶段
         }) 
       }
       const doWrite = content =>{
         // 执行 写 操作
         this.outputFileSystem.writeFile(targetPath, content, err => {})
       }
     };
     // 在 emit 阶段做了两件事：
     // 1. 获取输出路径
     // 2. 创建输出文件（具体写的内容，看emitFiles回调）
     this.hooks.emit.callAsync(compilation, err => {
   			if (err) return callback(err);
   			outputPath = compilation.getPath(this.outputPath, {});
   			mkdirp(this.outputFileSystem, outputPath, emitFiles);
   		});
   }
   ```

   









## 重点概念解析

1. `Dependency Graph` 的概念：[Dependency Graph](https://webpack.js.org/concepts/dependency-graph/#root)



## 参考资料

1. https://juejin.cn/post/6844903987129352206









