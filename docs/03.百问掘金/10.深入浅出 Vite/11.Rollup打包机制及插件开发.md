---
title: 11-Rollup打包机制及插件开发
date: 2023-04-03 22:43:53
permalink: /pages/d280b4/
categories:
  - 百问掘金
  - 深入浅出 Vite
tags:
  - 
---



## 0.前言

> 本节课程代码的[仓库 ](https://github.com/wangjs-jacky/Learn-Vite/tree/main/examples/13-vite-rollup)：`13-vite-rollup`

承接上文，本篇博客为《深入浅出 `Vite` 》掘金手册第十一章的总结。



## 1.构建机制

### 问题1：在Rollup一次完整的构建过程中，Rollup会经历哪两个阶段？每个阶段的作用是什么？

`Rollup` 内部会经历 `build` 和 `output` 两个大阶段

![](https://wjs-tik.oss-cn-shanghai.aliyuncs.com/202304032250858.png)

代码逻辑简化如下：

```javascript
// Build 阶段
const bundle = await rollup.rollup(inputOptions);

// Output 阶段
await Promise.all(outputOptions.map(bundle.write));

// 构建结束
await bundle.close();
```

`Build` 阶段：通过 `debug` 断点后，简化 `bundle` 对象（以简化部分）如下：

```json
{
  /* 缓存 ast 相关信息 */
  cache: {
    modules: [
      {
        assertions: {
        },
        ast: {
          .......
          sourceType: "module",
        },
        /* 构建后代码 */
        code: "export var add = function (a, b) { return a + b; };\r\nexport var multiple = function (a, b) { return a * b; };\r\n",
        /* 导入的模块 */
        id: "/Users/jiashengwang/Project/Learn-vite/examples/13-vite-rollup/src/basic/util.ts",
        moduleSideEffects: true,
        /* 源代码 */
        originalCode: "export const add = (a: number, b: number) => a + b;\n\nexport const multiple = (a: number, b: number) => a * b;\n",
      },
    ],
    /* 记录使用到的插件 */
    plugins: {},
    close: /* 关闭构建*/
    closed: /* 标识构建是否结束 */
    generate: /* 生成 chunk */
    write: /* 将 chunk 写入到磁盘 */
    watchFiles: [ /* 记录入口文件相关信息 */
    "/Users/../examples/13-vite-rollup/src/basic/index.ts",
    "/Users/../examples/13-vite-rollup/src/basic/util.ts",
  	],
  },
```

从上可以看出，`Build` 阶段主要完成的事情有：

1. `bundle` 对象的 `cache.modules` 中实际存储各个模块的内容（源码及构建后代码），模块依赖关系，以及解析后的  `ast` 树。
2. 暴露出三个函数：`generate` 、 `write` 和`close` 方法，用于进入到后的  `Outup` 阶段。 

`Output` 阶段：通过打断点  `const {output} = bundle.generate({})` 查看 `output` 对象。

分析如下：

```javascript
// 入口源码 src/basic/index.ts
import { add, multiple } from "./util";

console.log(add(1, 2));

// ========== 构建结果 ==========
{
  output: [
    {
      exports: [], /* 当前无导出 */
      facadeModuleId: "/Users/jiashengwang/Project/Learn-vite/examples/13-vite-rollup/src/basic/index.ts",
      isEntry: true,
      isDynamicEntry: false, /* 是否为动态导入入口模块 */
      isImplicitEntry: false, /* 是否为隐式入口模块 */
      isEntry: true, /* 是否为入口 */
      type: 'chunk', /* 类型 */
      /* 打包后的代码 */
      code: "import { add } from './util.85d9f98d.js';\n\nconsole.log(add(1, 2));\r\n/* console.log(multiple(2, 3)); */\n//# sourceMappingURL=index.ce505c09.js.map\n", 
      dynamicImports: [],
      fileName: "index.ce505c09.js", /* 构建后名称 */
      imports: [
        "util.85d9f98d.js", /* 导入的模块 */
      ],
      // 其余属性省略
    }
  ]
}
```

非入口文件分析：

```javascript
// src/basic/util.ts
export const add = (a: number, b: number) => a + b;
export const multiple = (a: number, b: number) => a * b;

// ========== 构建结果 ==========
{
  output: [
    {
      /* 导出的方法 */
      exports: [
        "add",
        "multiple",
    	], 
      facadeModuleId: "/Users/../examples/13-vite-rollup/src/basic/util.ts",
      isDynamicEntry: false,
      isImplicitEntry: false, 
      isEntry: true,
      type: 'chunk', /* 类型 */
      /* 打包后的代码 */
      code: "var add = function (a, b) { return a + b; };\r\nvar multiple = function (a, b) { return a * b; };\n\nexport { add, multiple };\n//# sourceMappingURL=util.85d9f98d.js.map\n",
      dynamicImports: [],
      fileName: "util.85d9f98d.js", /* 构建后名称 */
      imports: [],
      // 其余属性省略
    }
  ]
}
```

对应 `map` 文件结构：

```javascript
{
  output: [
    {
      fileName: "index.ce505c09.js.map",
      source: "{\"version\":3,\"file\":\"index.ce505c09.js\",\"sources\":[],\"sourcesContent\":[],\"names\":[],\"mappings\":\";;;\"}",
      type: "asset", /* 类型为 assets */
    },
    {
      fileName: "util.85d9f98d.js.map",
    }
  ]
}
```

最终的输出结果：

<img src="/Users/jiashengwang/Library/Application Support/typora-user-images/image-20230403232858652.png" alt="image-20230403232858652" style="zoom:80%;" />



### 问题2：rollup 中 Build Hook 和 Output Hook 的本质区别是什么？

插件的各种 Hook 可以根据这两个构建阶段分为两类: `Build Hook` 与 `Output Hook`。

- `Build Hook`：是以 `module` 作为处理边界。
- `Output Hook`：则是以 `Chunk` 作为处理边界。



### 问题3：根据 Hook 执行方式可以把插件分成哪五类？

`Rollup` 中的钩子类型应该也是参考 `tabpable` 这个库。

`hook`钩子类型大致可以分为 5 类：

1. 同步`Sync` or 非同步 `Async`。
2. 并行`Parallel` or 串行`Sequential` ：类比 `Promise.all` 和 `async + await`
3. `First`：类比 `Promise.race` 仅处理第一个返回值。

上述分类太八股了点，背住即可，实际流程还是挺简单的。



### 问题4：请描述一下Rollup插件在build阶段的工作流程？

`Build` 的执行流程图如下：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/58ce9fa2b0f14dd1bc50a9c849157e43~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)

主要记住以下几点即可：

1. 对于多个插件的启动是并发的，因此构建开始阶段 `buildStart `为 `parallel` 模式。

2. 而单个插件内部的执行流程是串行的。

   其中负责解析 `module` 的钩子，即 `resolve` + `load` 类属于 `First` 型。当某个模块被插件处理过后，其他模块无法处理了，如果此时仍需处理，可通过 `this.resolve()` 发起二次模块解析操作，这一点特性在`rollup` 插件阶段的 `alias` 插件时体现的很明显。

3. **核心构建流程**：`resolve `=> `load` => `transform`（字符串到字符串）=> `moduleParse`（字符串到 `ast` 树，这个阶段很耗时可以是并发模式）



### 问题5：请描述一下Rollup插件在Output阶段的工作流程？

**`Output` 的执行流程图如下：**

<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5dc4935d712d451fb6978fad46dd7b74~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" style="zoom:67%;" />

Build 和 Output 其实也挺像的，只是前者处理 `moudle`，或者处理 `chunk`，如何 `emit` 到磁盘：

1. 在执行多个插件时基本都是并发的。如`renderStart` 中并发执行所有插件的 `banner\footer\intro\outro` 钩子。这四个钩子功能很简单，就是往打包产物的固定位置(比如头部和尾部)插入一些自定义的内容，比如协议声明内容、项目介绍等等。
2. `writeBundle` 也是如此，构建结束后，`output` 结果为一个数组，根据数组中的 `filename` 去往磁盘中输出产物。
3. 特殊的钩子解析：
   - `augmentChunkHash`：决定是否要以 `hash` 方式命名。
   - `resolveFileUrl`：之前在构建 `__dirname` 时有使用过，此阶段遇到 `import.meta.url` 语句时，可通过此函数解析。（路径解析类的都属于 `First` 型）
   - `resolveImportMeta`：对于 `import.meta.属性` 语句时，可通过此函数解析。（路径解析类的都属于 `First` 型）
4. **构建的核心流程**： `renderChunk`=>`generateBundle`=>`writeBundle`



## 2. 官方插件源码解析

### 问题6：如何实现 `alias` 功能。

> 官方 [`alias` 实践 ](https://github.com/rollup/plugins/blob/master/packages/alias/src/index.ts) 功能很全，我在 [仓库 ](https://github.com/wangjs-jacky/Learn-Vite/blob/main/examples/13-vite-rollup/scripts/plugins/alias-plugin.ts)中仅实现了一个简易版本。

使用方式：

```javascript
// 官方实践
import alias from "@rollup/plugin-alias";
// 常用 inputOptions 配置
const inputOptions = {
  input: path.join(SRC_PATH, "plugin", "alias.js"),
  plugins: [
    otherPlugin(),
    myAlias({
      /* 将 util-a 这个虚假模块替换为 ./util.js 相对 */
      entries: [{ find: "util-a", replacement: "./util.js" }],
    }),
    alias({
      entries: [{ find: "util-b", replacement: "./util.js" }],
    }),
  ],
};
```

其中，`util-a` 和 `util-b` 为两个虚拟模块，使用官方实践处理 `util-b`，使用`myAlias` 处理 `util-a`。

```javascript
import { add } from "util-a";
import { multiple } from "util-b";
```

实践思路：

1. 通过 `resolveId` 筛选出 `util-a` 模块，筛选后通过字符串的 `replace` 函数替换成目标模块`./util.js`。
2. 特别注意时，由于 `resolveId` 属于`First` 型，当 `myAlias` 处理后，后续所有的插件将不再处理此模块，现在存在一个情况，转译后的 `./util.js` 有可能还会被二次处理。因此需要通过 `this` 上下文，进行模块二次触发。
3. 第二次触发时，`myAlias` 不需要再进行处理了，通过透传 `{ skipSelf: true }` 跳过当前构建。

简易版代码如下：

```javascript
/* 简易版-官方插件，经支持 find(不支持正则) 和 replacement 两个参数 */
function myAlias(options) {
  // 获取 entries 配置
  const { entries } = options;
  return {
    name: "myAlias",
    // 传入三个参数，当前模块路径、引用当前模块的模块路径、其余参数
    resolveId(importee, importer, resolveOptions) {
      log(importee, importer, "alias-plugin");
      // 根据 find 过滤出模块
      const matchedEntry = entries.find(
        (entry) =>
          /* matches(entry.find, importee), */
          entry.find === importee,
      );
      /* 判断是否为入口模块 */
      const isEntry = !importer;

      // 如果不能匹配替换规则，或者当前模块是入口模块，则不会继续后面的别名替换流程
      if (!matchedEntry || isEntry) {
        return null;
      }

      // 执行替换操作
      const updatedId = importee.replace(
        matchedEntry.find,
        matchedEntry.replacement,
      );

      /* ===== END ===== */
      /* 理论上替换完成后，直接 return string 或对象 即可，但是仍需考虑一个问题，
      转译后的模块(本例中为 "./util.js")需不需要被其他模块所处理。*/
      /* 因此：需通过  this.resolve 会执行所有插件(除当前插件外)的 resolveId 钩子，重新发起一轮构建去处理 "./util.js" 依赖。 */
      /* 新一轮依赖处理，当前插件无需处理，则可以通过传入第三个参数 {skipSelf: true} 跳过 */
      console.log("\n触发第二轮依赖解析......\n");
      return this.resolve(
        updatedId,
        importer,
        Object.assign({ skipSelf: true }, resolveOptions),
      ).then((resolved) => {
        // 替换后的路径即 updateId 会经过别的插件进行处理
        /* 如果是个真实的地址，最终会被 rollup 替换为绝对路径，若为虚拟模块的话 */

        let finalResult = resolved;
        if (!finalResult) {
          // 如果其它插件没有处理这个路径，则直接返回 updateId
          finalResult = { id: updatedId };
        }
        return finalResult;
      });
    },
  };
}
```

这边为了能更好的看出二次依赖解析的过程，封装 `log` 函数打印处理结果。

```javascript
function log(importee, importer, pluginName) {
  const isEntry = !importer;
  if (isEntry) {
    console.log(`${pluginName}解析: 入口文件`);
  } else {
    console.log(`${pluginName}解析: ${importee}`);
  }
}
```

执行：`npm run plugin:alias` ，打印结果如下：

```shell
otherPlugin解析: 入口文件
myAlias解析: 入口文件 
otherPlugin解析: util-a
otherPlugin解析: util-b
myAlias解析: util-a

触发第二轮依赖解析......

myAlias解析: util-b
otherPlugin解析: ./util.js
otherPlugin 可以捕获到经 alias 插件 replace 后的模块
otherPlugin解析: ./util.js
otherPlugin 可以捕获到经 alias 插件 replace 后的模块
myAlias解析: ./util.js
🚀 Build Finished!
```

可以发现如下：

- 插件生效时为**并发**，因此两个插件 `myAlias` 和 `otherPlugin` 同时处理入口依赖。且整体执行次序按照`plugins` 的书写顺序。

  ```shell
  otherPlugin解析: 入口文件
  myAlias解析: 入口文件 
  ```

- 单个插件属于串行，因此两个插件会依次触发解析 `util-a` 和 `util-b` 两个包。

  ```shell
  otherPlugin解析: util-a
  otherPlugin解析: util-b
  myAlias解析: util-a 
  // 调用 this.resolve 此为 async 模式。
  myAlias解析: util-b
  ```

  因为 `util-a` 符合 `alias` 的 `find` 条件，会被转译为 `./util.js`，触发二次依赖解析。会在 `myAlias` 触发结束后执行 `this.resolve` 函数。这就是 `hook` 钩子为 `async` 的体现。

- 由于 `{ skipSelf: true }` 二次构建时，只有 `otherPlugin`  和官方的 `alias` 参与解析。

  ```shell
  otherPlugin解析: ./util.js
  otherPlugin 可以捕获到经 alias 插件 replace 后的模块
  ```

  当 `alias` 模块解析到 `util-b` 时，也会触发二次构建，因此最后执行：

  ```shell
  otherPlugin解析: ./util.js
  otherPlugin 可以捕获到经 alias 插件 replace 后的模块
  ```

分析结束，感觉我这个例子设计的超级好，读懂这个例子就能完全明白 `hook` 5种类型的实际含义了。



### 问题7：如何支持图片格式的插件？



### 问题8：如何实现一个全局替换插件？

